/*#include <iostream>
using namespace std;
// n refers to the length of b[], which is smaller than thh length of a[] by 1;//void bestBST(float a[], float b[] , float m[][6], float w[][6], int s[][6], int n){        for(int i=0;i<=n;i++){                w[i+1][i]=b[i];                m[i+1][i]=0;        }        for(int r=1;r<=n;r++)                for(int i=1;i<=n-r;i++){                        int j=i+r;                        w[i][j]=w[i][j-1]+a[j]+b[j];                        m[i][j]=m[i+1][j];                        s[i][j]=i;                        for(int k=i+1;k<=j;k++){                                float t=m[i][k-1]+m[k+1][j];                                if(t<m[i][j]){                                        m[i][j]=t;                                        s[i][j]=k;                                }                        m[i][j]+=w[i][j];                        }                }}
int main()
{
    //float a[]={0.06,0.08,0.10,0.12,0.14,0.16,0.18};    //float b[]={0,0.10,0.02,0.03,0.04,0.01,0.01};    float a[]={0 ,0.15 ,0.10 ,0.05 ,0.10 ,0.20};    float b[]={0.05 ,0.10 ,0.05 ,0.05 ,0.05 ,0.10};    float M[][6],W[7][6];    int S[7][6];    bestBST(a,b,M,W,S,5);    cout<<"b[1] to b[6]:";    for(int i=0;i<6;i++) cout<<b[i]<<" ";    cout<<endl;    cout<<"a[1] to a[5]:";    for(int i=1;i<6;i++) cout<<a[i]<<" ";    cout<<endl;    cout<<"The ASL of the best BST is "<<M[1][6]<<endl;    cout<<"The root of this tree is "<<S[1][6]<<endl;
    return 0;
}*/#include<cstdio>#include<cfloat>#include<iostream>#define INF DBL_MAX#define m_Size 100using namespace std;double m[m_Size][m_Size];int root[m_Size][m_Size];void optimal_BST(double p[],double q[],int n)//p[1,n]表示实结点的概率,q[0,n]表示虚拟结点的搜索概率，n表示实结点的个数{        double w[n+2][n+2];        for(int i=1 ; i<=n+1 ; i++){                m[i][i-1] = q[i-1];                w[i][i-1] = q[i-1];        }        for(int l =1 ; l<=n ; l++)                for(int i= 1 ; i<=n-l+1 ; ++i){                        int j = i+l-1;                        m[i][j] = INF;                        w[i][j] = w[i][j-1] +p[j]+q[j];                        for(int r = i;r<=j ; r++){                                double t = m[i][r-1]+m[r+1][j]+w[i][j];                                if(t<m[i][j]){                                root[i][j] = r;                                m[i][j] = t;                                }                        }                }}// 输出最优二叉树// ij代表首尾位置、初始时p置为0，表明当前无根结点void out_BST(int i,int j,int p){        //叶节点 判断其位置        if(i-j==1)        {                if(j<p) printf("b%d is a%d left child\n",j,p);                else printf("b%d is a%d right child\n",j,p);                return;        }        //根结点 输出根位置 迭代        if(p==0)        {                p = root[i][j];                printf("a%d is root\n",p);                out_BST(i,p-1,p);                out_BST(p+1,j,p);        } else if(root[i][j] <p)        {//根的左子树                printf("a%d is a%d left child\n",root[i][j],p);                p = root[i][j];                out_BST(i,p-1,p);                out_BST(p+1,j,p);        }  else        {//根的右子树                printf("a%d is a%d right child\n",root[i][j],p);                p = root[i][j];                out_BST(i,p-1,p);                out_BST(p+1,j,p);        }}
int main(){        double a[]={0,0.10,0.15,0.20,0.15,0.10};        double b[]={0.02,0.03,0.10,0.10,0.02,0.03};        int n=sizeof(a)/sizeof(a[0])-1;        cout<<"ture gailv a[1:5]: ";        for(int i=1;i<=n;i++) cout<<a[i]<<" "; cout<<endl;        cout<<"the probability of virtual dot is : b[0:5] ";        for(int i=0;i<=n;i++) cout<<a[i]<<" "; cout<<endl;        optimal_BST(a,b,n);        cout<<endl<<"the shortest average distance is: "<<m[1][n]<<endl;        out_BST(1,n,0);        cout<<endl<<"root tree:"<<endl;//根构造树        for(int i=1;i<=n;i++){                for(int j=1;j<=n;j++)                        cout<<root[i][j]<<'\t';                cout<<endl;        }        return 0;}